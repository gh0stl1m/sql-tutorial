= DB/SQL-Tutorial

Una pequeña introduccion a conceptos sobre SQL y bases de datos con algunos ejemplos. Algunos conceptos o definiciones pueden ser especificas de MySQL pero se pueden extrapolar a otros motores de base de datos.

== ¿Que es una base de datos?

* Una base de datos o banco de datos es un conjunto de datos pertenecientes a un mismo contexto y almacenados sistemáticamente para su posterior uso. 

* Una biblioteca puede considerarse una base de datos compuesta en su mayoría por documentos y textos impresos en papel e indexados para su consulta. 

* Actualmente, y debido al desarrollo tecnológico de campos como la informática y la electrónica, la mayoría de las bases de datos están en formato digital (electrónico), y por ende se ha desarrollado y se ofrece un amplio rango de soluciones al problema del almacenamiento de datos.

== Distintos DBMS

* Algunas de los mas comunes son Oracle, MySQL, SQL Server, PostgreSQL, Firebird, MariaDB, SQL Lite.

image::images/DBMS.jpg[DBMS]

*SGBD (Sistema de gestión de bases de datos) = DBMS (Database Management System)*

== ¿Que es MySQL?

MySQL es un sistema de gestión de bases de datos relacional, multihilo y multiusuario.

== Unix Daemons/Windows Services

Un demonio o servicio es un tipo especial de proceso no interactivo, es decir, que se ejecuta en segundo plano en lugar de ser controlado directamente por el usuario. Este tipo de programas se ejecutan de forma continua (infinita).

== Arquitectura Cliente/Servidor

image::images/Architecture.jpg[Architecture]

* Servidor: Se encarga de recoger, interpretar y ejecutar todas las peticiones de los usuarios de la base de datos.

* Cliente: Es la parte con la que trabajarán directamente los usuarios.

== Conectividad Cliente/Servidor

* ODBC (Open Database Connectivity): Es un API standard para comunicarse con cualquier base de datos.
* ADO: Es el API standard de .NET para comunicarse con distintas bases de datos.
* JDBC (Java Database Connectivity): Es el API standard de Java para comunicarse con distintas bases de datos.

== DB Engine

El motor de base de dato sirven para definir, construir y manipular una base de datos.

* Definir una base de datos: Consisten en especificar los tipos de datos, estructuras y restricciones para los datos que se almacenaran.
* Construir una base de datos: Es el proceso de almacenar los datos sobre algun medio de almacenamiento. Ver: Storage Engine.
* Manipular una base de datos: Incluye funciones como consultas, actualizacion, etc. de bases de datos.

== Storage Engine

Algunas bases de datos nos permiten configurar el tipo de almacenamiento para sus tablas, dependiendo el caso podriamos querer usar alguno distinto. MySQL provee multiples tipos de almacenamientos, aunque los dos mas populares son InnoDB y MyISAM. InnoDB es el storage por defecto.

=== InnoDB
* Soporte de transacciones.
* Bloqueo de registros.
* Nos permite tener las características ACID (Atomicity, Consistency, Isolation and Durability), garantizando la integridad de nuestras tablas.
* Es probable que si nuestra aplicación hace un uso elevado de INSERT y UPDATE notemos un aumento de rendimiento con respecto a MyISAM.
=== MyISAM
* Mayor velocidad en general a la hora de recuperar datos.
* Recomendable para aplicaciones en las que dominan las sentencias SELECT ante los INSERT / UPDATE.
* Ausencia de características de atomicidad ya que no tiene que hacer comprobaciones de la integridad referencial, ni bloquear las tablas para realizar las operaciones, esto nos lleva como los anteriores puntos a una mayor velocidad.

== ACID

* Atomicidad (Atomicity): La Atomicidad requiere que cada transacción sea "todo o nada": si una parte de la transacción falla, todas las operaciones de la transacción fallan, y por lo tanto la base de datos no sufre cambios. Un sistema atómico tiene que garantizar la atomicidad en cualquier operación y situación, incluyendo fallas de alimentación eléctrica, errores y caidas del sistema.
* Consistencia (Consistency): La propiedad de Consistencia se asegura que cualquier transacción llevará a la base de datos de un estado válido a otro estado válido. Cualquier dato que se escriba en la base de datos tiene que ser válido de acuerdo a todas las reglas definidas, incluyendo (pero no limitado a) los constraints, los cascades, los triggers, y cualquier combinación de estos.
* Aislamiento (Isolation): El aislamiento ("Isolation" en inglés) se asegura que la ejecución concurrente de las transacciones resulte en un estado del sistema que se obtendría si estas transacciones fueran ejecutadas una atrás de otra. Cada transacción debe ejecutarse en aislamiento total; por ejemplo, si T1 y T2 se ejecutan concurrentemente, luego cada una debe mantenerse independiente de la otra.
* Durabilidad (Durability): La durabilidad significa que una vez que se confirmó una transacción (commit), quedará persistida, incluso ante eventos como pérdida de alimentación eléctrica, errores y caidas del sistema. Por ejemplo, en las bases de datos relacionales, una vez que se ejecuta un grupo de sentencias SQL, los resultados tienen que almacenarse inmediatamente (incluso si la base de datos se cae inmediatamente luego).

== SQL vs ANSI SQL

El SQL es un lenguaje de acceso a bases de datos que explota la flexibilidad y potencia de los sistemas relacionales y permite así gran variedad de operaciones.

image::images/ANSI.jpg[ANSI]

*Comentarios*: El unico tipo de comentario que es ANSI es el que empieza con '--'

== Commands vs SQL

* SQL (Structured Query Language): Es un lenguaje declarativo de acceso a bases de datos relacionales. i.e: SELECT * FROM people.

* Commands (Comandos): Son instrucciones que brinda el servidor de bases de datos para obtener determinada información. i.e: SHOW DATABASES.

== SQL Sentences

image::images/Sentences.jpg[SQL Sentences]

== Data Modeling

image::images/DataModeling.jpg[Data Modeling]

== MySQL Data Types

=== Numeric Types
|=======
|Tipo de Campo|Tamaño de Almacenamiento|Mínimo (Signed/Unsigned)|Máximo (Signed/Unsigned)
|TINYINT|1 byte|-128/0|127/255
|SMALLINT|2 bytes|-32768/0|32767/65535
|MEDIUMINT|3 bytes|-8388608/0|8388607/16777215
|INT, INTEGER|4 bytes|-2147483648/0|2147483647/4294967295
|BIGINT|8 bytes|-9223372036854775808/0|9223372036854775807/18446744073709551615
|FLOAT|4 bytes||
|FLOAT(x)|4 bytes if 0 \<= x \<= 24, 8 bytes if 25 \<= x \<= 53||
|DOUBLE|8 bytes||
|DECIMAL(M,D), NUMERIC (M, D)|||
|BIT(M)|Aproximadamente (M+7)/8 bytes||
|=======

=== Date Types
|=======
|Tipo de Campo|Tamaño de Almacenamiento|Zero Value
|DATE|3 bytes|'0000-00-00'
|DATETIME|8 bytes|'0000-00-00 00:00:00'
|TIMESTAMP|4 bytes|00000000000000
|TIME|3 bytes|'00:00:00'
|YEAR|1 byte|0000
|=======

* Date: Almacena fechas en formato YYYY-MM-DD
* Datetime: Almacena fechas en formato YYYY-MM-DD HH:MM:SS
* Timestamp: Almacena fechas en formato YYYY-MM-DD HH:MM:SS pero con conversión entre el Timezone actual y UTC.
* Time: Almacena  HH:MM:SS
* Year: Almacena el año en formato YYYY o YY.

Si las fechas son invalidad son convertidas a "zero" value.

=== String Types
|=======
|Tipo de columna|Almacenamiento requerido|Máxima Longitud
|CHAR(M)|M bytes, 0 \<= M \<= 255|255
|VARCHAR(M)|L+1 bytes, donde L \<= M y 0 \<= M \<= 255|255
|BINARY(M)|M bytes, 0 \<= M \<= 255|255
|VARBINARY(M)|L+1 bytes, donde L \<= M y 0 \<= M \<= 255|255
|TINYBLOB, TINYTEXT|L+1 byte, donde L < 2^8|255
|BLOB, TEXT|L+2 bytes, donde L < 2^16|65535
|MEDIUMBLOB, MEDIUMTEXT|L+3 bytes, donde L < 2^24|16,777,215
|LONGBLOB, LONGTEXT|L+4 bytes, donde L < 2^32|4,294,967,295
|=======

|=======
|Valor|CHAR(4)|Almacenamiento Necesario|VARCHAR(4)|Almacenamiento Necesario
|''|'----'|4 bytes|''|1 byte
|'ab'|'ab--'|4 bytes|'ab'|3 byte
|'abcd'|'abcd'|4 bytes|'abcd'|5 byte
|'abcdefgh'|'abcd'|4 bytes|'abcd'|5 byte
|=======

=== Additional Types
|=======
|Tipo de columna|Almacenamiento requerido|Máxima Longitud
|ENUM('value1','value2',...)|1 o 2 bytes, dependiendo del número de valores de la enumeración (65,535 valores máximo)|65,535 Miembros
|SET('value1','value2',...)|1, 2, 3, 4, o 8 bytes, dependiendo del número de miembros del conjunto (64 miembros máximo)|64 Miembros
|=======

==== Enum
* Sólo contiene un valor
* Se puede definir la lista de hasta 65535 valores distintos
* Si se permite NULL, este será el valor por defecto; sinó, y si no se define con DEFAULT, será el primer valor de la lista (en el ejemplo de arriba, si no defino el DEFAULT ‘medium’, por defecto sería ‘small’)
* Cada valor de la lista es numerado con un índice (empieza desde el 1), pudiendo usar el índice en vez del valor de la lista (en el ejemplo de arriba: 1=>’small’, 2=>’medium’ y 3=>’large’)
* En caso de introducir un valor no perteciente a la lista, el campo pasará a valer ”, una cadena vacía, que tiene el índice zero
* El índice de NULL es NULL,
* Para retornar el índice de un campo del tipo ENUM, podemos sumar zero al campo (SELECT size+0 FROM …)
* De almacenamiento físico, ocupará 1 byte si hay 255 o menos valores en la lista, o 2 bytes si hay 256 o más valores

==== Set

* Contiene zero, uno o varios valores
* Se puede definir la lista de hasta 64 valores distintos
* Los valores no pueden contener comas, ya que los valores asignados son separados por comas
* Cada valor de la lista representa un bit de la cadena de bits del campo
* El valor decimal del campo determina los bits, marcando los valores que contiene el campo,de manera que si todos los bits estan a 1, es que ese campo contiene todos los valores (ejemplo: si el valor decimal es 7, en binario sería 0111, y eso quiere decir que el campo contiene los valore 'a', 'b' y 'c')

|=======
|SET|Decimal|Bytes
|'a'|1|0001
|'b'|2|0010
|'c'|4|0100
|'d'|8|1000
|=======
* De almacenamiento físico, ocupará 1, 2, 3, 4, o 8 bytes, según la longitud de la lista de valores (si N es el número de valores, la formula es (N+7)/8 bytes)

== Column Attributes

* PK (Primary Key): Indica si la columna forma parte de la clave principal. Hay claves simples o compuestas (Mas de una columna). En general toda tabla tiene PK.
* NN (Not Null): Indica que esta columna no puede ser NULL. NULL no es vacio ni 0, seria como indefinido.
* UQ (Unique Index): Indica que esta columna no tendrá ningún valor repetido.
* BIN (Is Binary Column): Indica que esta columna se almacenara en modo “Binario”. Respeta mayúsculas y minúsculas usando el collation binario.
* UN (Unsigned Data Type): Indica que esta columna no usara un byte para el signo, ósea números positivos solamente.
* ZF (Zero Fill): El campo se completara con ceros si es numérico.
* AI (Auto Incremental): El campo incrementa solo su valor. Cada tabla solo acepta un auto incremental y si hay tiene que formar parte de la PK.
* G (Generated): Este tipo de campo es calculado en base a una expresión que puede utilizar el valor de otras columnas.

== Charset/Collation

* Charset: Hace referencia al conjunto de caracteres y como persistir los mismos.
* Collation: Es un juego de reglas para comparar y ordenar caracteres de un conjunto de caracteres.

[source,sql]
--
-- Muestra los CHARSETs instalados
SHOW CHARACTER SET;
-- Muestra COLLATIONS instalados
SHOW COLLATION;
--

[source,sql]
--
-- Parte 1
-- Creamos la tabla
DROP TABLE IF EXISTS collation_prueba;

CREATE TABLE IF NOT EXISTS collation_prueba (
    columna_1 CHAR(5) CHARSET utf8 COLLATE utf8_unicode_ci,
    columna_2 CHAR(5) CHARSET latin1 COLLATE latin1_general_cs,
    columna_3 CHAR(5) CHARSET ASCII COLLATE ascii_general_ci,
    columna_4 CHAR(5) CHARSET utf8 COLLATE utf8_bin,
    columna_5 CHAR(5) CHARSET latin1 COLLATE latin1_bin,
    columna_6 CHAR(5) CHARSET ASCII COLLATE ascii_bin
);

-- Parte 2
-- Insertamos los datos
INSERT INTO collation_prueba VALUES ('Ñandú','Ñandú','Nandu','Ñandú','Ñandú','Nandu');

-- Parte 3
-- Analizamos el tamaño en bytes y cantidad de caracteres en los distintos charsets (Ver Nota 1 y 2)
SELECT LENGTH(columna_1) AS 'BinaryLength01', CHAR_LENGTH(columna_1) AS 'CharLength01' FROM collation_prueba
UNION ALL
SELECT LENGTH(columna_2) AS 'BinaryLength02', CHAR_LENGTH(columna_2) AS 'CharLength02' FROM collation_prueba
UNION ALL
SELECT LENGTH(columna_3) AS 'BinaryLength03', CHAR_LENGTH(columna_3) AS 'CharLength03' FROM collation_prueba;

-- Parte 4
-- Analizamos como el collation afecta las comparaciones binarias (Ver Nota 3)
SELECT * FROM collation_prueba WHERE columna_1 LIKE 'N%';
SELECT * FROM collation_prueba WHERE columna_1 LIKE 'ñ%';
SELECT * FROM collation_prueba WHERE columna_1 LIKE 'Ñ%';
SELECT * FROM collation_prueba WHERE columna_4 LIKE 'N%';
SELECT * FROM collation_prueba WHERE columna_4 LIKE 'ñ%';
SELECT * FROM collation_prueba WHERE columna_4 LIKE 'Ñ%';

-- Parte 5
-- Analizamos como el collation afecta el ordenamiento (Ver Nota 4)
CREATE TABLE IF NOT EXISTS spanish_collation (
	columna_1 VARCHAR(15) CHARSET utf8 COLLATE utf8_spanish_ci,
    columna_2 VARCHAR(15) CHARSET utf8 COLLATE utf8_spanish2_ci
);

INSERT INTO spanish_collation VALUES
('Baño', 'Baño'),('Carlos', 'Carlos'),
('Cruzada', 'Cruzada'),('Chile', 'Chile'),
('Llorar', 'Llorar'),('Lámina', 'Lámina'),
('Loreto', 'Loreto'),('Dedo', 'Dedo');

SELECT * FROM spanish_collation ORDER BY columna_1;
SELECT * FROM spanish_collation ORDER BY columna_2;
--

*1)* Lo primero que debemos notar es que el Charset ASCII no permite ingresar otra cosa que no esté en la tabla ASCII predeterminada, así que la letra "Ñ" y aquellas letras con tilde quedan absolutamente descartadas.

*2)* Como vemos, en UTF-8 se guardaron 7 bytes de información (un byte extra en la letra "Ñ", otro byte extra en la letra "ú") pero el largo de cada cadena en cada caso es de 5 caracteres.

*3)* Las primeras 3 (CHARSET utf8 COLLATE utf8_general_ci) devolverán un registro cada uno, mientras que de las últimas 3 (CHARSET utf8 COLLATE utf8_bin) sólo el último devolverá un resultado positivo.Esto se debe a que la columna "name01" tiene COLLATION utf8-general-ci, que, entre otras cosas, considera como sinónimo la letra "N" y "Ñ", y además es case-insensitive (utf8-general-ci). Esto también se aplica a los tildes, de forma que si buscamos por ñandu (sin tilde) el resultado entregado será el mismo que si buscamos por "Ñandú". De igual forma, "ÑaÑdU" igual entregará un resultado positivo para "Ñandú".En las últimas 3 sin embargo, si no buscamos exactamente por lo ingresado en la base de datos no se devolverá ningún registro, así que cualquier cosa que no sea un match exacto de "Ñandú" simplemente se descartará.

*4)* Una COLLATION utf8_spanish_ci ordenará los registros de una forma mientras que utf8_spanish2_ci la ordenará de otra, debido a que el español tradicional considera "ch" como una letra entre la "C" y la "D". Asimismo, considera el uso de la letra "LL" como una letra entre la "L" y "M".

== Indexes

Cuando creamos un índices lo hacemos con el objectivo de acelerar futuras busquedas sobre los datos que poseemos. Cada motor de base de datos ofrece distintos tipos de índices pero varias son comunes y algunos son mas especificos para cada DB.
MySQL hay cinco tipos de índices:

* PRIMARY KEY: Este índice se ha creado para generar consultas especialmente rápidas, debe ser único y no se admite el almacenamiento de NULL.
* INDEX (Non-Unique): Son usados indistintamente por MySQL, permite crear índices sobre una columna, sobre varias columnas o sobre partes de una columna.
* UNIQUE: Este tipo de índice no permite el almacenamiento de valores iguales.
* FULLTEXT: Permiten realizar búsquedas de palabras. Sólo pueden usarse sobre columnas CHAR, VARCHAR o TEXT.
* SPATIAL: Este tipo de índices solo puede usarse sobre columnas de datos geométricos (spatial) y en el motor MyISAM.

== Temporary Tables

En algunas DB podemos crear tablas temporales, la ventaja de estas tablas es que son solo visibles dentro de la conexión en cuales fueron creadas y al cerrar la conexión serán eliminadas, de esta manera dos personas con distintas conexiones podrían usar el mismo nombre para una tabla del tipo temporal. Además estas tablas son borradas automáticamente al cerrar la conexión.
En general se usan para cálculos auxiliares ya sea consolidar datos o aplicar criterios de búsqueda o agrupación.

== DDL Sentences

Vamos a ver algunas sentencias del tipo DDL (Data Definition Language).

=== Creacion
[source,sql]
--
-- Crea el schema donde vamos a trabajar.
CREATE SCHEMA tutorial;

-- Podemos ejecutar la misma sentencia pero solo se ejecutara si la DB no existe.
CREATE DATABASE IF NOT EXISTS tutorial;

-- Creamos una tabla 
CREATE TABLE tutorial.alumnos (
    id_alumno INT UNSIGNED NOT NULL AUTO_INCREMENT,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    dni VARCHAR(20) NOT NULL,
    fecha_nacimiento DATE NOT NULL,
    materias_cursadas TINYINT UNSIGNED NULL DEFAULT 0,
    promedio FLOAT NULL,
    activo BIT(1) NOT NULL DEFAULT 1,
    PRIMARY KEY (id_alumno)
);

-- Creamos un Unique Index sobre la columna dni
CREATE UNIQUE INDEX idx_dni_unique ON tutorial.alumnos(dni ASC);

-- Podemos crear una View (Es una forma simple de poner un "alias" a una consulta compleja)
CREATE VIEW tutorial.alumnos_aprobados AS
    SELECT * FROM tutorial.alumnos WHERE promedio >= 7;

-- Podemos crear un Stored Procedure (Seria algo similar a un script de sentencias SQL)
DELIMITER $$
CREATE PROCEDURE tutorial.eliminar_alumnos_desactivados ()
BEGIN
    DELETE FROM tutorial.alumnos WHERE activo = 0;
END $$
--

*Nota*: Otra forma posible de crear una tabla es desde el resultado de una sentencia SELECT.
[source,sql]
--
CREATE TABLE alumnos_backup
SELECT
    *
FROM
    alummnos;
--

=== Borrado
[source,sql]
--
DROP INDEX idx_dni_unique ON tutorial.alumnos;

DROP TABLE tutorial.alumnos;

DROP VIEW tutorial.alumnos_aprobados;

DROP PROCEDURE tutorial.eliminar_alumnos_desactivados;

DROP DATABASE IF EXISTS tutorial;

DROP SCHEMA tutorial;
--

=== Modificacion
[source,sql]
--
ALTER TABLE tutorial.alumnos
    ADD COLUMN primera_columna VARCHAR(50) NULL DEFAULT 'Primera' FIRST;

ALTER TABLE tutorial.alumnos
    ADD COLUMN ultima_columna VARCHAR(50) NULL DEFAULT 'Ultima';

ALTER TABLE tutorial.alumnos 
    ADD COLUMN siguiente_columna VARCHAR(50) NULL DEFAULT 'Siguiente' AFTER fecha_nacimiento;

ALTER TABLE tutorial.alumnos 
    ADD INDEX idx_nombre (nombre ASC);

ALTER TABLE tutorial.alumnos 
    DROP COLUMN primera_columna;

ALTER TABLE tutorial.alumnos 
    DROP COLUMN siguiente_columna, 
    DROP COLUMN ultima_columna;

ALTER TABLE tutorial.alumnos
    ADD COLUMN direccion VARHCAR(100) NULL,
    ADD COLUMN codigo_alumno INT NULL,
    ADD INDEX idx_codigo_alumno (codigo_alumno ASC);

RENAM TABLE alumnos TO rename_alumnos;
--

== DML

Para empezar a probar las distintas sentencias DML podemos utilizar el archivo link:backup/DB.sql["DB.sql"] para crear e inicializar nuestra DB.

=== SELECT

La clausula SELECT sirve para seleccionar datos.
[source,sql]
--
-- Muestra todos los registros de la tabla alumnos y todas sus columnas
SELECT * FROM alumnos;
-- Muestra todos los registros de la tabla alumnos pero solo dos columnas
SELECT id_alumno, nombre FROM alumnos;
-- Suma dos numeros y devuelve su resultado en una columna llamada "Suma"
SELECT 2 + 2 AS Suma;
-- Muestra la frase "Hola Mundo" en una columna llamada "Texto"
SELECT 'Hola Mundo' AS Texto;
-- Utiliza una funcion que recibe varias cadenas de caracteres y las concatenas
SELECT CONCAT('Hola', 'Mundo') AS Resultado;
--

=== SELECT + WHERE

La clausula WHERE sirve para agregar condiciones de filtrado para los datos.
[source,sql]
--
-- Seleccionamos todos los alumnos donde sus promedio es 7
SELECT * FROM alumnos WHERE promedio = 7;
-- Seleccionamos todos los alumnos donde sus promedio es NULL (Indefinido)
SELECT * FROM alumnos WHERE promedio \<\=> NULL;
-- Seleccionamos todos los alumnos donde sus promedio es NULL (Indefinido)
SELECT * FROM alumnos WHERE promedio IS NULL;

-- Selecionamos todos los alumnos donde su promedio es mayor o igual a 4 y la cantidad de materias cursadas mayor a 3
SELECT * FROM alumnos WHERE promedio >= 4 AND materias_cursadas > 3;

-- Selecionamos todos los alumnos dodne sus promedio es 6 o 8.5
SELECT * FROM alumnos WHERE promedio = 6 OR promedio = 8.5;
--

=== Operadores de comparación

|=======
|Operador|Descripción
|\<=|Menor o igual
|<|Menor
|>|Mayor
|>=|Mayor o igual
|!=, <>|Distinto
|\<\=>|Comparación Segura
|=======

*Nota*: El operador "=" devuelve siempre NULL si alguna de las dos partes es NULL en cambio el operador "\<\=>" compara el valor contra NULL y devuelve su valor de verdad. Si ambos son NULL retorna 1, y en el caso de un NULL retorna 0.

[source,sql]
--
-- Devuelve 0 filas
SELECT * FROM institutos WHERE cantidad_personal > 50 AND barrio = NULL;

-- Devuelve 1 fila
SELECT * FROM institutos WHERE cantidad_personal > 50 AND barrio \<\=> NULL;

-- Devuelve 4 filas
SELECT * FROM institutos WHERE cantidad_personal > 100 AND barrio = NULL;

-- Devuelve 5 fila
SELECT * FROM institutos WHERE cantidad_personal > 100 AND barrio \<\=> NULL;
--
=== Operadores lógicos (AND/OR)

|=======
|Expr1|Expr2|Expr1 AND Expr2
|FALSO|FALSO|*FALSO*
|FALSO|VERDADERO|*FALSO*
|VERDADERO|FALSO|*FALSO*
|VERDADERO|VERDADERO|*VERDADERO*
|FALSO|NULL|*FALSO*
|NULL|FALSO|*FALSO*
|VERDADERO|NULL|*NULL*
|NULL|VERDADERO|*NULL*
|=======

|=======
|Expr1|Expr2|Expr1 OR Expr2
|FALSO|FALSO|*FALSO*
|FALSO|VERDADERO|*VERDADERO*
|VERDADERO|FALSO|*VERDADERO*
|VERDADERO|VERDADERO|*VERDADERO*
|FALSO|NULL|*NULL*
|NULL|FALSO|*NULL*
|VERDADERO|NULL|*VERDADERO*
|NULL|VERDADERO|*VERDADERO*
|=======

=== Operadores lógicos (XOR)

|=======
|Expr1|Expr2|Expr1 OR Expr2
|FALSO|FALSO|*FALSO*
|FALSO|VERDADERO|*VERDADERO*
|VERDADERO|FALSO|*VERDADERO*
|VERDADERO|VERDADERO|*FALSO*
|FALSO|NULL|*NULL*
|NULL|FALSO|*NULL*
|VERDADERO|NULL|*NULL*
|NULL|VERDADERO|*NULL*
|=======

=== Sentencia Between

Between se usa para filtrado por rangos. Esta se puede aplicar con números, fechas. Se puede usar con el NOT.

[source,sql]
--
-- Recuperamos todos los alumnos que tienen entre 1 y 5 materias cursadas
SELECT * FROM alumnos WHERE materias_cursadas BETWEEN AND 5;

-- Recuperamos todos los alumnos que NO tienen entre 1 y 5 materias cursadas, pueden ser mas o menos
SELECT * FROM alumnos WHERE materias_cursadas NOT BETWEEN AND 5;

-- Recuperamos todos los alumnos que su fecha de nacimiento esta dentro de un rango especifico
SELECT * FROM alumnos WHERE fecha_nacimiento BETWEEN '1980-01-01' AND '1986-01-07';

-- Recuperamos todos los alumnos que su fecha de nacimiento NO esta dentro de un rango especifico
SELECT * FROM alumnos WHERE fecha_nacimiento NOT BETWEEN '1980-01-01' AND '1986-01-07';

-- Recuperamos todos los alumnos que el campo auditoria esta dentro de un rango especifico (Es importante notar que el campo es del tipo TIMESTAMP por eso necesitamos incluir hora:minutos:segundos para el filtrado)
SELECT * FROM alumnos WHERE auditoria BETWEEN '2013-01-01 00:00:00' AND '2013-03-17 23:59:59'

-- Recuperamos todos los alumnos que el campo auditoria No esta dentro de un rango especifico
SELECT * FROM alumnos WHERE auditoria NOT BETWEEN '2013-01-01 00:00:00' AND '2013-03-17 23:59:59'
--